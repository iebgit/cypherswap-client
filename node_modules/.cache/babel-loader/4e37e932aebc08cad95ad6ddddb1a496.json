{"ast":null,"code":"import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n  send(method, params) {\n    const request = {\n      method: method,\n      params: params,\n      id: this._nextId++,\n      jsonrpc: \"2.0\"\n    };\n    if (this._pendingBatch == null) {\n      this._pendingBatch = [];\n    }\n    const inflightRequest = {\n      request,\n      resolve: null,\n      reject: null\n    };\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n    this._pendingBatch.push(inflightRequest);\n    if (!this._pendingBatchAggregator) {\n      // Schedule batch for next event loop + short duration\n      this._pendingBatchAggregator = setTimeout(() => {\n        // Get teh current batch and clear it, so new requests\n        // go into the next batch\n        const batch = this._pendingBatch;\n        this._pendingBatch = null;\n        this._pendingBatchAggregator = null;\n        // Get the request as an array of requests\n        const request = batch.map(inflight => inflight.request);\n        this.emit(\"debug\", {\n          action: \"requestBatch\",\n          request: deepCopy(request),\n          provider: this\n        });\n        return fetchJson(this.connection, JSON.stringify(request)).then(result => {\n          this.emit(\"debug\", {\n            action: \"response\",\n            request: request,\n            response: result,\n            provider: this\n          });\n          // For each result, feed it to the correct Promise, depending\n          // on whether it was a success or error\n          batch.forEach((inflightRequest, index) => {\n            const payload = result[index];\n            if (payload.error) {\n              const error = new Error(payload.error.message);\n              error.code = payload.error.code;\n              error.data = payload.error.data;\n              inflightRequest.reject(error);\n            } else {\n              inflightRequest.resolve(payload.result);\n            }\n          });\n        }, error => {\n          this.emit(\"debug\", {\n            action: \"response\",\n            error: error,\n            request: request,\n            provider: this\n          });\n          batch.forEach(inflightRequest => {\n            inflightRequest.reject(error);\n          });\n        });\n      }, 10);\n    }\n    return promise;\n  }\n}","map":{"version":3,"sources":["../src.ts/json-rpc-batch-provider.ts"],"names":[],"mappings":"AACA,SAAS,QAAQ,QAAQ,2BAA2B;AACpD,SAAS,SAAS,QAAQ,oBAAoB;AAE9C,SAAS,eAAe,QAAQ,qBAAqB;AAErD;AAEA,OAAM,MAAO,oBAAqB,SAAQ,eAAe,CAAA;EAQrD,IAAI,CAAC,MAAc,EAAE,MAAkB,EAAA;IACnC,MAAM,OAAO,GAAG;MACZ,MAAM,EAAE,MAAM;MACd,MAAM,EAAE,MAAM;MACd,EAAE,EAAG,IAAI,CAAC,OAAO,EAAG;MACpB,OAAO,EAAE;KACZ;IAED,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,EAAE;MAC5B,IAAI,CAAC,aAAa,GAAG,EAAG;IAC3B;IAED,MAAM,eAAe,GAAQ;MAAE,OAAO;MAAE,OAAO,EAAE,IAAI;MAAE,MAAM,EAAE;IAAI,CAAE;IAErE,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAI;MAC5C,eAAe,CAAC,OAAO,GAAG,OAAO;MACjC,eAAe,CAAC,MAAM,GAAG,MAAM;IACnC,CAAC,CAAC;IAEF,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC;IAExC,IAAI,CAAC,IAAI,CAAC,uBAAuB,EAAE;MAC/B;MACA,IAAI,CAAC,uBAAuB,GAAG,UAAU,CAAC,MAAK;QAE3C;QACA;QACA,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa;QAChC,IAAI,CAAC,aAAa,GAAG,IAAI;QACzB,IAAI,CAAC,uBAAuB,GAAG,IAAI;QAEnC;QACA,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAE,QAAQ,IAAK,QAAQ,CAAC,OAAO,CAAC;QAEzD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;UACf,MAAM,EAAE,cAAc;UACtB,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC;UAC1B,QAAQ,EAAE;SACb,CAAC;QAEF,OAAO,SAAS,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAE,MAAM,IAAI;UACvE,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,MAAM,EAAE,UAAU;YAClB,OAAO,EAAE,OAAO;YAChB,QAAQ,EAAE,MAAM;YAChB,QAAQ,EAAE;WACb,CAAC;UAEF;UACA;UACA,KAAK,CAAC,OAAO,CAAC,CAAC,eAAe,EAAE,KAAK,KAAI;YACrC,MAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC;YAC7B,IAAI,OAAO,CAAC,KAAK,EAAE;cACf,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC;cACxC,KAAM,CAAC,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI;cAChC,KAAM,CAAC,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI;cACtC,eAAe,CAAC,MAAM,CAAC,KAAK,CAAC;aAChC,MAAM;cACH,eAAe,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1C;UACL,CAAC,CAAC;QAEN,CAAC,EAAG,KAAK,IAAI;UACT,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,MAAM,EAAE,UAAU;YAClB,KAAK,EAAE,KAAK;YACZ,OAAO,EAAE,OAAO;YAChB,QAAQ,EAAE;WACb,CAAC;UAEF,KAAK,CAAC,OAAO,CAAE,eAAe,IAAI;YAC9B,eAAe,CAAC,MAAM,CAAC,KAAK,CAAC;UACjC,CAAC,CAAC;QACN,CAAC,CAAC;MAEN,CAAC,EAAE,EAAE,CAAC;IACT;IAED,OAAO,OAAO;EAClB;AACH","sourceRoot":"","sourcesContent":["import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=json-rpc-batch-provider.js.map"]},"metadata":{},"sourceType":"module"}