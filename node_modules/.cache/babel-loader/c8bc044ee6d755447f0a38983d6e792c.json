{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Animator = void 0;\nvar react_1 = require(\"react\");\nvar prop_types_1 = __importDefault(require(\"prop-types\"));\nvar constants_1 = require(\"../constants\");\nvar makeScheduler_1 = require(\"../utils/makeScheduler\");\nvar getChildrenNodesSequenceActivationTimes_1 = require(\"../utils/getChildrenNodesSequenceActivationTimes\");\nvar getChildrenNodesStaggerActivationTimes_1 = require(\"../utils/getChildrenNodesStaggerActivationTimes\");\nvar AnimatorContext_1 = require(\"../AnimatorContext\");\nvar useAnimatorGeneral_1 = require(\"../useAnimatorGeneral\");\nvar useAnimator_1 = require(\"../useAnimator\");\nvar ANIMATE_DEFAULT = true;\nvar DURATION_DEFAULT = Object.freeze({\n  enter: 100,\n  exit: 100,\n  stagger: 25,\n  delay: 0,\n  offset: 0\n});\nvar animatorEmptySettings = {};\nvar classInstanceIdCounter = 0;\nvar Animator = function (props) {\n  var _a;\n  var _b = props.animator,\n    animator = _b === void 0 ? animatorEmptySettings : _b,\n    children = props.children;\n  var parentAnimatorGeneral = useAnimatorGeneral_1.useAnimatorGeneral();\n  var parentAnimator = useAnimator_1.useAnimator();\n  // Since the expected boolean values applicable to the node are provided down\n  // to the next child node, they are converted to booleans always to prevent\n  // possible data leaking.\n  var isParentAnimated = parentAnimator ? !!parentAnimator.animate : ANIMATE_DEFAULT;\n  var animate = animator.animate !== undefined ? !!animator.animate : isParentAnimated;\n  var root = parentAnimator ? !!animator.root : true;\n  var merge = !root && !!animator.merge;\n  var combine = !!animator.combine;\n  var manager = (_a = animator.manager) !== null && _a !== void 0 ? _a : constants_1.PARALLEL;\n  var instanceId = react_1.useState(function () {\n    return classInstanceIdCounter++;\n  })[0];\n  var scheduler = react_1.useState(function () {\n    return makeScheduler_1.makeScheduler();\n  })[0];\n  // All the <Animator/> children non-root instances.\n  var childrenNodesMap = react_1.useState(function () {\n    return new Map();\n  })[0];\n  var dynamicDuration = react_1.useRef(undefined);\n  // This variable is supposed to be defined by the component using this\n  // <Animator/>. It will contain the reference(s) to the actual HTML element(s)\n  // to animate on the flow transitions and component lifecycles.\n  var animateRefs = react_1.useRef([]);\n  // Since the animator data is passed to different contexts, if it were to be\n  // a \"useState\", a stale version of the data would be passed. So this is a\n  // \"persistent animator data reference\" across different contexts.\n  // It must be the same as \"publicAnimatorRef\" for consistency.\n  var _persistentAnimatorRef = react_1.useRef(null);\n  var getPersistentAnimatorRef = function () {\n    return _persistentAnimatorRef.current;\n  };\n  // It is initially empty to trigger an initial flow diff and call the\n  // event callbacks in the first render.\n  var previousAnimatorRef = react_1.useRef();\n  var createAnimatorRef = function (providedFlowValue) {\n    var _a, _b;\n    var oldAnimatorRef = getPersistentAnimatorRef();\n    var duration = Object.freeze(__assign(__assign(__assign(__assign({}, DURATION_DEFAULT), parentAnimatorGeneral === null || parentAnimatorGeneral === void 0 ? void 0 : parentAnimatorGeneral.duration), animator.duration), dynamicDuration.current));\n    // The flow object is not directly updated.\n    // It is always updated based on its next flow value.\n    var newFlow;\n    if (!oldAnimatorRef) {\n      var value = animate ? constants_1.EXITED : constants_1.ENTERED;\n      var hasEntered = value === constants_1.ENTERED;\n      var hasExited = value === constants_1.EXITED;\n      newFlow = Object.freeze((_a = {\n        value: value\n      }, _a[value] = true, _a.hasEntered = hasEntered, _a.hasExited = hasExited, _a));\n    } else {\n      var value = providedFlowValue !== null && providedFlowValue !== void 0 ? providedFlowValue : oldAnimatorRef.flow.value;\n      var hasEntered = (oldAnimatorRef === null || oldAnimatorRef === void 0 ? void 0 : oldAnimatorRef.flow.hasEntered) || value === constants_1.ENTERED;\n      var hasExited = (oldAnimatorRef === null || oldAnimatorRef === void 0 ? void 0 : oldAnimatorRef.flow.hasExited) || value === constants_1.EXITED;\n      newFlow = Object.freeze((_b = {\n        value: value\n      }, _b[value] = true, _b.hasEntered = hasEntered, _b.hasExited = hasExited, _b));\n    }\n    var flow = newFlow;\n    var setupAnimateRefs = function () {\n      var refs = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        refs[_i] = arguments[_i];\n      }\n      animateRefs.current = refs;\n    };\n    var updateDuration = function (newDynamicDuration) {\n      if (combine) {\n        console.error('Animator can not update duration dynamically when \"combine\" is enabled.');\n        return;\n      }\n      dynamicDuration.current = newDynamicDuration;\n      updateAnimatorRef(createAnimatorRef());\n    };\n    var _id = instanceId;\n    var _subscribe = function (id, node) {\n      childrenNodesMap.set(id, node);\n    };\n    var _unsubscribe = function (id) {\n      childrenNodesMap.delete(id);\n    };\n    return Object.freeze({\n      animate: animate,\n      root: root,\n      merge: merge,\n      combine: combine,\n      manager: manager,\n      duration: duration,\n      flow: flow,\n      setupAnimateRefs: setupAnimateRefs,\n      updateDuration: updateDuration,\n      _id: _id,\n      _subscribe: _subscribe,\n      _unsubscribe: _unsubscribe\n    });\n  };\n  // \"_persistentAnimatorRef\" and \"publicAnimatorRef\" must be the same data.\n  // \"_persistentAnimatorRef\" is passed to different contexts to prevent\n  // stale data since it is a \"useRef\". \"publicAnimatorRef\" is passed as provided\n  // React context value to trigger renders.\n  // Both values should be updated only with \"updateAnimatorRef\".\n  if (!_persistentAnimatorRef.current) {\n    var valueRef = _persistentAnimatorRef;\n    valueRef.current = createAnimatorRef();\n  }\n  var _c = react_1.useState(_persistentAnimatorRef.current),\n    publicAnimatorRef = _c[0],\n    _setPublicAnimatorRef = _c[1];\n  var updateAnimatorRef = function (newAnimatorRef) {\n    var valueRef = _persistentAnimatorRef;\n    valueRef.current = newAnimatorRef;\n    _setPublicAnimatorRef(newAnimatorRef);\n  };\n  var childActivations = react_1.useRef(null);\n  var generateChildActivations = function (flowValue) {\n    var animatorRef = getPersistentAnimatorRef();\n    var duration = animatorRef.duration;\n    var nodes = Array.from(childrenNodesMap.values());\n    var nodesToUpdate = [];\n    // On EXITED, no nodes should be updated.\n    if (combine) {\n      nodesToUpdate = nodes;\n    } else if (flowValue === constants_1.ENTERING) {\n      nodesToUpdate = nodes.filter(function (node) {\n        return node.getIsMerge();\n      });\n    } else if (flowValue === constants_1.ENTERED) {\n      nodesToUpdate = nodes.filter(function (node) {\n        return !node.getIsMerge();\n      });\n    } else if (flowValue === constants_1.EXITING) {\n      nodesToUpdate = nodes;\n    }\n    // On EXITING, all nodes exit at the same time in parallel.\n    if (flowValue === constants_1.EXITING || manager === constants_1.PARALLEL) {\n      // Since all the children will be transitioned in parallel, a possible\n      // approach is to make the process synchronous so the scheduler only makes\n      // one task. This becomes a bottle-neck if there are more animated nodes\n      // than the machine CPU can handle and eventually block the thread.\n      // So each node is transitioned separately to prevent this case.\n      var totalDuration_1 = 0;\n      var times = nodesToUpdate.map(function (node) {\n        totalDuration_1 = Math.max(totalDuration_1, flowValue === constants_1.EXITING ? node.getDuration().exit : node.getDuration().enter);\n        return {\n          node: node,\n          time: 0\n        };\n      });\n      childActivations.current = {\n        duration: totalDuration_1,\n        times: times\n      };\n    } else if (flowValue === constants_1.EXITED) {\n      childActivations.current = {\n        times: []\n      };\n    } else if (manager === constants_1.SEQUENCE) {\n      childActivations.current = getChildrenNodesSequenceActivationTimes_1.getChildrenNodesSequenceActivationTimes(nodesToUpdate);\n    } else if (manager === constants_1.STAGGER) {\n      childActivations.current = getChildrenNodesStaggerActivationTimes_1.getChildrenNodesStaggerActivationTimes(nodesToUpdate, duration);\n    } else if (typeof manager === 'function') {\n      childActivations.current = manager({\n        nodes: nodesToUpdate,\n        duration: duration\n      });\n    } else if (process.env.NODE_ENV !== 'production') {\n      console.error(\"Animator manager \\\"\" + String(manager) + \"\\\" is not supported.\");\n    }\n  };\n  var generateActivationsDuration = function (newFlowValue) {\n    var _a;\n    var _b, _c, _d;\n    var animatorRef = getPersistentAnimatorRef();\n    if (!combine) {\n      return animatorRef.duration;\n    }\n    generateChildActivations(newFlowValue);\n    if (process.env.NODE_ENV !== 'production' && typeof manager === 'function' && !((_b = childActivations.current) === null || _b === void 0 ? void 0 : _b.duration) && ((_c = childActivations.current) === null || _c === void 0 ? void 0 : _c.times.length)) {\n      console.error(['Animator with custom \"manager\" and \"combine\" enabled should return a child', 'activations \"duration\". Otherwise the Animator duration will use the default', 'value and it will not reflect the real combination of the durations.'].join('\\n'));\n    }\n    var durationChangedKey = newFlowValue === constants_1.EXITING ? 'exit' : 'enter';\n    var durationValueDefault = durationChangedKey === 'enter' ? animatorRef.duration.enter : animatorRef.duration.exit;\n    var durationValue = ((_d = childActivations.current) === null || _d === void 0 ? void 0 : _d.duration) || durationValueDefault;\n    return __assign(__assign({}, animatorRef.duration), (_a = {}, _a[durationChangedKey] = durationValue, _a));\n  };\n  var setFlowValue = function (newFlowValue) {\n    if (!combine) {\n      generateChildActivations(newFlowValue);\n    }\n    var newAnimatorRef = createAnimatorRef(newFlowValue);\n    updateAnimatorRef(newAnimatorRef);\n  };\n  var setActivate = function (activate) {\n    var flow = getPersistentAnimatorRef().flow;\n    if (activate) {\n      if (flow.value === constants_1.ENTERING || flow.value === constants_1.ENTERED) {\n        return;\n      }\n      var duration_1 = generateActivationsDuration(constants_1.ENTERING);\n      scheduler.start(duration_1.delay, function () {\n        setFlowValue(constants_1.ENTERING);\n        scheduler.start(duration_1.enter, function () {\n          return setFlowValue(constants_1.ENTERED);\n        });\n      });\n    } else {\n      if (flow.value === constants_1.EXITING || flow.value === constants_1.EXITED) {\n        return;\n      }\n      var duration_2 = generateActivationsDuration(constants_1.EXITING);\n      scheduler.start(0, function () {\n        setFlowValue(constants_1.EXITING);\n        scheduler.start(duration_2.exit, function () {\n          return setFlowValue(constants_1.EXITED);\n        });\n      });\n    }\n  };\n  react_1.useEffect(function () {\n    var _a;\n    if (!animate) {\n      return;\n    }\n    // TODO: What if node is changed from child node to root node and needs\n    // to be unsuscribed from its parent?\n    if (!root) {\n      var id = instanceId;\n      var getDuration = function () {\n        return getPersistentAnimatorRef().duration;\n      };\n      var getIsMerge = function () {\n        return getPersistentAnimatorRef().merge;\n      };\n      var child = Object.freeze({\n        id: id,\n        getDuration: getDuration,\n        getIsMerge: getIsMerge,\n        setActivate: setActivate\n      });\n      parentAnimator === null || parentAnimator === void 0 ? void 0 : parentAnimator._subscribe(instanceId, child);\n    }\n    (_a = animator.onAnimateMount) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n    return function () {\n      var _a;\n      scheduler.stopAll();\n      (_a = animator.onAnimateUnmount) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n      if (!root) {\n        parentAnimator === null || parentAnimator === void 0 ? void 0 : parentAnimator._unsubscribe(instanceId);\n      }\n    };\n  }, []);\n  react_1.useEffect(function () {\n    var _a, _b, _c, _d, _e, _f, _g;\n    if (!animate) {\n      return;\n    }\n    var animatorRef = getPersistentAnimatorRef();\n    var flow = animatorRef.flow;\n    // An animated root node is by default activated.\n    if (root) {\n      setActivate(animator.activate !== false);\n    }\n    // If the flow value was changed in this update.\n    if (((_a = previousAnimatorRef.current) === null || _a === void 0 ? void 0 : _a.flow.value) !== flow.value) {\n      (_b = animator.onTransition) === null || _b === void 0 ? void 0 : _b.call(animator, flow);\n      switch (flow.value) {\n        case constants_1.ENTERING:\n          (_c = animator.onAnimateEntering) === null || _c === void 0 ? void 0 : _c.call.apply(_c, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n          break;\n        case constants_1.ENTERED:\n          (_d = animator.onAnimateEntered) === null || _d === void 0 ? void 0 : _d.call.apply(_d, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n          break;\n        case constants_1.EXITING:\n          (_e = animator.onAnimateExiting) === null || _e === void 0 ? void 0 : _e.call.apply(_e, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n          break;\n        case constants_1.EXITED:\n          (_f = animator.onAnimateExited) === null || _f === void 0 ? void 0 : _f.call.apply(_f, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n          break;\n      }\n      if ((_g = childActivations.current) === null || _g === void 0 ? void 0 : _g.times.length) {\n        var newChildrenActivation_1 = flow.value === constants_1.ENTERING || flow.value === constants_1.ENTERED;\n        childActivations.current.times.forEach(function (_a) {\n          var node = _a.node,\n            time = _a.time;\n          return scheduler.start(node.id, time, function () {\n            return node.setActivate(newChildrenActivation_1);\n          });\n        });\n      }\n    }\n    previousAnimatorRef.current = animatorRef;\n  }, [parentAnimatorGeneral, parentAnimator, animator, publicAnimatorRef]);\n  return react_1.createElement(AnimatorContext_1.AnimatorContext.Provider, {\n    value: publicAnimatorRef\n  }, children);\n};\nexports.Animator = Animator;\nAnimator.propTypes = {\n  // @ts-expect-error\n  animator: prop_types_1.default.shape({\n    duration: prop_types_1.default.shape({\n      enter: prop_types_1.default.number,\n      exit: prop_types_1.default.number,\n      stagger: prop_types_1.default.number,\n      delay: prop_types_1.default.number,\n      offset: prop_types_1.default.number\n    }),\n    animate: prop_types_1.default.bool,\n    root: prop_types_1.default.bool,\n    merge: prop_types_1.default.bool,\n    combine: prop_types_1.default.bool,\n    manager: prop_types_1.default.oneOfType([prop_types_1.default.oneOf([constants_1.PARALLEL, constants_1.SEQUENCE, constants_1.STAGGER]), prop_types_1.default.func]),\n    onAnimateMount: prop_types_1.default.func,\n    onAnimateEntering: prop_types_1.default.func,\n    onAnimateEntered: prop_types_1.default.func,\n    onAnimateExiting: prop_types_1.default.func,\n    onAnimateExited: prop_types_1.default.func,\n    onAnimateUnmount: prop_types_1.default.func,\n    activate: prop_types_1.default.bool,\n    onTransition: prop_types_1.default.func\n  }),\n  children: prop_types_1.default.any\n};","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArrays","il","r","Array","k","a","j","jl","__importDefault","mod","__esModule","defineProperty","exports","value","Animator","react_1","require","prop_types_1","constants_1","makeScheduler_1","getChildrenNodesSequenceActivationTimes_1","getChildrenNodesStaggerActivationTimes_1","AnimatorContext_1","useAnimatorGeneral_1","useAnimator_1","ANIMATE_DEFAULT","DURATION_DEFAULT","freeze","enter","exit","stagger","delay","offset","animatorEmptySettings","classInstanceIdCounter","props","_a","_b","animator","children","parentAnimatorGeneral","useAnimatorGeneral","parentAnimator","useAnimator","isParentAnimated","animate","undefined","root","merge","combine","manager","PARALLEL","instanceId","useState","scheduler","makeScheduler","childrenNodesMap","Map","dynamicDuration","useRef","animateRefs","_persistentAnimatorRef","getPersistentAnimatorRef","current","previousAnimatorRef","createAnimatorRef","providedFlowValue","oldAnimatorRef","duration","newFlow","EXITED","ENTERED","hasEntered","hasExited","flow","setupAnimateRefs","refs","_i","updateDuration","newDynamicDuration","console","error","updateAnimatorRef","_id","_subscribe","id","node","set","_unsubscribe","delete","valueRef","_c","publicAnimatorRef","_setPublicAnimatorRef","newAnimatorRef","childActivations","generateChildActivations","flowValue","animatorRef","nodes","from","values","nodesToUpdate","ENTERING","filter","getIsMerge","EXITING","totalDuration_1","times","map","Math","max","getDuration","time","SEQUENCE","getChildrenNodesSequenceActivationTimes","STAGGER","getChildrenNodesStaggerActivationTimes","process","env","NODE_ENV","String","generateActivationsDuration","newFlowValue","_d","join","durationChangedKey","durationValueDefault","durationValue","setFlowValue","setActivate","activate","duration_1","start","duration_2","useEffect","child","onAnimateMount","stopAll","onAnimateUnmount","_e","_f","_g","onTransition","onAnimateEntering","onAnimateEntered","onAnimateExiting","onAnimateExited","newChildrenActivation_1","forEach","createElement","AnimatorContext","Provider","propTypes","default","shape","number","bool","oneOfType","oneOf","func","any"],"sources":["/Users/Ibis/Projects/project_mern_memories/client/node_modules/@arwes/animation/lib/Animator/Animator.component.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Animator = void 0;\nvar react_1 = require(\"react\");\nvar prop_types_1 = __importDefault(require(\"prop-types\"));\nvar constants_1 = require(\"../constants\");\nvar makeScheduler_1 = require(\"../utils/makeScheduler\");\nvar getChildrenNodesSequenceActivationTimes_1 = require(\"../utils/getChildrenNodesSequenceActivationTimes\");\nvar getChildrenNodesStaggerActivationTimes_1 = require(\"../utils/getChildrenNodesStaggerActivationTimes\");\nvar AnimatorContext_1 = require(\"../AnimatorContext\");\nvar useAnimatorGeneral_1 = require(\"../useAnimatorGeneral\");\nvar useAnimator_1 = require(\"../useAnimator\");\nvar ANIMATE_DEFAULT = true;\nvar DURATION_DEFAULT = Object.freeze({\n    enter: 100,\n    exit: 100,\n    stagger: 25,\n    delay: 0,\n    offset: 0\n});\nvar animatorEmptySettings = {};\nvar classInstanceIdCounter = 0;\nvar Animator = function (props) {\n    var _a;\n    var _b = props.animator, animator = _b === void 0 ? animatorEmptySettings : _b, children = props.children;\n    var parentAnimatorGeneral = useAnimatorGeneral_1.useAnimatorGeneral();\n    var parentAnimator = useAnimator_1.useAnimator();\n    // Since the expected boolean values applicable to the node are provided down\n    // to the next child node, they are converted to booleans always to prevent\n    // possible data leaking.\n    var isParentAnimated = parentAnimator ? !!parentAnimator.animate : ANIMATE_DEFAULT;\n    var animate = animator.animate !== undefined ? !!animator.animate : isParentAnimated;\n    var root = parentAnimator ? !!animator.root : true;\n    var merge = !root && !!animator.merge;\n    var combine = !!animator.combine;\n    var manager = (_a = animator.manager) !== null && _a !== void 0 ? _a : constants_1.PARALLEL;\n    var instanceId = react_1.useState(function () { return classInstanceIdCounter++; })[0];\n    var scheduler = react_1.useState(function () { return makeScheduler_1.makeScheduler(); })[0];\n    // All the <Animator/> children non-root instances.\n    var childrenNodesMap = react_1.useState(function () { return new Map(); })[0];\n    var dynamicDuration = react_1.useRef(undefined);\n    // This variable is supposed to be defined by the component using this\n    // <Animator/>. It will contain the reference(s) to the actual HTML element(s)\n    // to animate on the flow transitions and component lifecycles.\n    var animateRefs = react_1.useRef([]);\n    // Since the animator data is passed to different contexts, if it were to be\n    // a \"useState\", a stale version of the data would be passed. So this is a\n    // \"persistent animator data reference\" across different contexts.\n    // It must be the same as \"publicAnimatorRef\" for consistency.\n    var _persistentAnimatorRef = react_1.useRef(null);\n    var getPersistentAnimatorRef = function () { return _persistentAnimatorRef.current; };\n    // It is initially empty to trigger an initial flow diff and call the\n    // event callbacks in the first render.\n    var previousAnimatorRef = react_1.useRef();\n    var createAnimatorRef = function (providedFlowValue) {\n        var _a, _b;\n        var oldAnimatorRef = getPersistentAnimatorRef();\n        var duration = Object.freeze(__assign(__assign(__assign(__assign({}, DURATION_DEFAULT), parentAnimatorGeneral === null || parentAnimatorGeneral === void 0 ? void 0 : parentAnimatorGeneral.duration), animator.duration), dynamicDuration.current));\n        // The flow object is not directly updated.\n        // It is always updated based on its next flow value.\n        var newFlow;\n        if (!oldAnimatorRef) {\n            var value = animate ? constants_1.EXITED : constants_1.ENTERED;\n            var hasEntered = value === constants_1.ENTERED;\n            var hasExited = value === constants_1.EXITED;\n            newFlow = Object.freeze((_a = { value: value }, _a[value] = true, _a.hasEntered = hasEntered, _a.hasExited = hasExited, _a));\n        }\n        else {\n            var value = providedFlowValue !== null && providedFlowValue !== void 0 ? providedFlowValue : oldAnimatorRef.flow.value;\n            var hasEntered = (oldAnimatorRef === null || oldAnimatorRef === void 0 ? void 0 : oldAnimatorRef.flow.hasEntered) || value === constants_1.ENTERED;\n            var hasExited = (oldAnimatorRef === null || oldAnimatorRef === void 0 ? void 0 : oldAnimatorRef.flow.hasExited) || value === constants_1.EXITED;\n            newFlow = Object.freeze((_b = { value: value }, _b[value] = true, _b.hasEntered = hasEntered, _b.hasExited = hasExited, _b));\n        }\n        var flow = newFlow;\n        var setupAnimateRefs = function () {\n            var refs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                refs[_i] = arguments[_i];\n            }\n            animateRefs.current = refs;\n        };\n        var updateDuration = function (newDynamicDuration) {\n            if (combine) {\n                console.error('Animator can not update duration dynamically when \"combine\" is enabled.');\n                return;\n            }\n            dynamicDuration.current = newDynamicDuration;\n            updateAnimatorRef(createAnimatorRef());\n        };\n        var _id = instanceId;\n        var _subscribe = function (id, node) {\n            childrenNodesMap.set(id, node);\n        };\n        var _unsubscribe = function (id) {\n            childrenNodesMap.delete(id);\n        };\n        return Object.freeze({\n            animate: animate,\n            root: root,\n            merge: merge,\n            combine: combine,\n            manager: manager,\n            duration: duration,\n            flow: flow,\n            setupAnimateRefs: setupAnimateRefs,\n            updateDuration: updateDuration,\n            _id: _id,\n            _subscribe: _subscribe,\n            _unsubscribe: _unsubscribe\n        });\n    };\n    // \"_persistentAnimatorRef\" and \"publicAnimatorRef\" must be the same data.\n    // \"_persistentAnimatorRef\" is passed to different contexts to prevent\n    // stale data since it is a \"useRef\". \"publicAnimatorRef\" is passed as provided\n    // React context value to trigger renders.\n    // Both values should be updated only with \"updateAnimatorRef\".\n    if (!_persistentAnimatorRef.current) {\n        var valueRef = _persistentAnimatorRef;\n        valueRef.current = createAnimatorRef();\n    }\n    var _c = react_1.useState(_persistentAnimatorRef.current), publicAnimatorRef = _c[0], _setPublicAnimatorRef = _c[1];\n    var updateAnimatorRef = function (newAnimatorRef) {\n        var valueRef = _persistentAnimatorRef;\n        valueRef.current = newAnimatorRef;\n        _setPublicAnimatorRef(newAnimatorRef);\n    };\n    var childActivations = react_1.useRef(null);\n    var generateChildActivations = function (flowValue) {\n        var animatorRef = getPersistentAnimatorRef();\n        var duration = animatorRef.duration;\n        var nodes = Array.from(childrenNodesMap.values());\n        var nodesToUpdate = [];\n        // On EXITED, no nodes should be updated.\n        if (combine) {\n            nodesToUpdate = nodes;\n        }\n        else if (flowValue === constants_1.ENTERING) {\n            nodesToUpdate = nodes.filter(function (node) { return node.getIsMerge(); });\n        }\n        else if (flowValue === constants_1.ENTERED) {\n            nodesToUpdate = nodes.filter(function (node) { return !node.getIsMerge(); });\n        }\n        else if (flowValue === constants_1.EXITING) {\n            nodesToUpdate = nodes;\n        }\n        // On EXITING, all nodes exit at the same time in parallel.\n        if (flowValue === constants_1.EXITING || manager === constants_1.PARALLEL) {\n            // Since all the children will be transitioned in parallel, a possible\n            // approach is to make the process synchronous so the scheduler only makes\n            // one task. This becomes a bottle-neck if there are more animated nodes\n            // than the machine CPU can handle and eventually block the thread.\n            // So each node is transitioned separately to prevent this case.\n            var totalDuration_1 = 0;\n            var times = nodesToUpdate.map(function (node) {\n                totalDuration_1 = Math.max(totalDuration_1, flowValue === constants_1.EXITING ? node.getDuration().exit : node.getDuration().enter);\n                return { node: node, time: 0 };\n            });\n            childActivations.current = { duration: totalDuration_1, times: times };\n        }\n        else if (flowValue === constants_1.EXITED) {\n            childActivations.current = { times: [] };\n        }\n        else if (manager === constants_1.SEQUENCE) {\n            childActivations.current = getChildrenNodesSequenceActivationTimes_1.getChildrenNodesSequenceActivationTimes(nodesToUpdate);\n        }\n        else if (manager === constants_1.STAGGER) {\n            childActivations.current = getChildrenNodesStaggerActivationTimes_1.getChildrenNodesStaggerActivationTimes(nodesToUpdate, duration);\n        }\n        else if (typeof manager === 'function') {\n            childActivations.current = manager({ nodes: nodesToUpdate, duration: duration });\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            console.error(\"Animator manager \\\"\" + String(manager) + \"\\\" is not supported.\");\n        }\n    };\n    var generateActivationsDuration = function (newFlowValue) {\n        var _a;\n        var _b, _c, _d;\n        var animatorRef = getPersistentAnimatorRef();\n        if (!combine) {\n            return animatorRef.duration;\n        }\n        generateChildActivations(newFlowValue);\n        if (process.env.NODE_ENV !== 'production' &&\n            typeof manager === 'function' &&\n            !((_b = childActivations.current) === null || _b === void 0 ? void 0 : _b.duration) && ((_c = childActivations.current) === null || _c === void 0 ? void 0 : _c.times.length)) {\n            console.error([\n                'Animator with custom \"manager\" and \"combine\" enabled should return a child',\n                'activations \"duration\". Otherwise the Animator duration will use the default',\n                'value and it will not reflect the real combination of the durations.'\n            ].join('\\n'));\n        }\n        var durationChangedKey = newFlowValue === constants_1.EXITING ? 'exit' : 'enter';\n        var durationValueDefault = durationChangedKey === 'enter'\n            ? animatorRef.duration.enter\n            : animatorRef.duration.exit;\n        var durationValue = ((_d = childActivations.current) === null || _d === void 0 ? void 0 : _d.duration) || durationValueDefault;\n        return __assign(__assign({}, animatorRef.duration), (_a = {}, _a[durationChangedKey] = durationValue, _a));\n    };\n    var setFlowValue = function (newFlowValue) {\n        if (!combine) {\n            generateChildActivations(newFlowValue);\n        }\n        var newAnimatorRef = createAnimatorRef(newFlowValue);\n        updateAnimatorRef(newAnimatorRef);\n    };\n    var setActivate = function (activate) {\n        var flow = getPersistentAnimatorRef().flow;\n        if (activate) {\n            if (flow.value === constants_1.ENTERING || flow.value === constants_1.ENTERED) {\n                return;\n            }\n            var duration_1 = generateActivationsDuration(constants_1.ENTERING);\n            scheduler.start(duration_1.delay, function () {\n                setFlowValue(constants_1.ENTERING);\n                scheduler.start(duration_1.enter, function () { return setFlowValue(constants_1.ENTERED); });\n            });\n        }\n        else {\n            if (flow.value === constants_1.EXITING || flow.value === constants_1.EXITED) {\n                return;\n            }\n            var duration_2 = generateActivationsDuration(constants_1.EXITING);\n            scheduler.start(0, function () {\n                setFlowValue(constants_1.EXITING);\n                scheduler.start(duration_2.exit, function () { return setFlowValue(constants_1.EXITED); });\n            });\n        }\n    };\n    react_1.useEffect(function () {\n        var _a;\n        if (!animate) {\n            return;\n        }\n        // TODO: What if node is changed from child node to root node and needs\n        // to be unsuscribed from its parent?\n        if (!root) {\n            var id = instanceId;\n            var getDuration = function () { return getPersistentAnimatorRef().duration; };\n            var getIsMerge = function () { return getPersistentAnimatorRef().merge; };\n            var child = Object.freeze({\n                id: id,\n                getDuration: getDuration,\n                getIsMerge: getIsMerge,\n                setActivate: setActivate\n            });\n            parentAnimator === null || parentAnimator === void 0 ? void 0 : parentAnimator._subscribe(instanceId, child);\n        }\n        (_a = animator.onAnimateMount) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n        return function () {\n            var _a;\n            scheduler.stopAll();\n            (_a = animator.onAnimateUnmount) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n            if (!root) {\n                parentAnimator === null || parentAnimator === void 0 ? void 0 : parentAnimator._unsubscribe(instanceId);\n            }\n        };\n    }, []);\n    react_1.useEffect(function () {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (!animate) {\n            return;\n        }\n        var animatorRef = getPersistentAnimatorRef();\n        var flow = animatorRef.flow;\n        // An animated root node is by default activated.\n        if (root) {\n            setActivate(animator.activate !== false);\n        }\n        // If the flow value was changed in this update.\n        if (((_a = previousAnimatorRef.current) === null || _a === void 0 ? void 0 : _a.flow.value) !== flow.value) {\n            (_b = animator.onTransition) === null || _b === void 0 ? void 0 : _b.call(animator, flow);\n            switch (flow.value) {\n                case constants_1.ENTERING:\n                    (_c = animator.onAnimateEntering) === null || _c === void 0 ? void 0 : _c.call.apply(_c, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n                    break;\n                case constants_1.ENTERED:\n                    (_d = animator.onAnimateEntered) === null || _d === void 0 ? void 0 : _d.call.apply(_d, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n                    break;\n                case constants_1.EXITING:\n                    (_e = animator.onAnimateExiting) === null || _e === void 0 ? void 0 : _e.call.apply(_e, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n                    break;\n                case constants_1.EXITED:\n                    (_f = animator.onAnimateExited) === null || _f === void 0 ? void 0 : _f.call.apply(_f, __spreadArrays([animator, publicAnimatorRef], animateRefs.current));\n                    break;\n            }\n            if ((_g = childActivations.current) === null || _g === void 0 ? void 0 : _g.times.length) {\n                var newChildrenActivation_1 = flow.value === constants_1.ENTERING || flow.value === constants_1.ENTERED;\n                childActivations.current.times.forEach(function (_a) {\n                    var node = _a.node, time = _a.time;\n                    return scheduler.start(node.id, time, function () { return node.setActivate(newChildrenActivation_1); });\n                });\n            }\n        }\n        previousAnimatorRef.current = animatorRef;\n    }, [parentAnimatorGeneral, parentAnimator, animator, publicAnimatorRef]);\n    return react_1.createElement(AnimatorContext_1.AnimatorContext.Provider, { value: publicAnimatorRef }, children);\n};\nexports.Animator = Animator;\nAnimator.propTypes = {\n    // @ts-expect-error\n    animator: prop_types_1.default.shape({\n        duration: prop_types_1.default.shape({\n            enter: prop_types_1.default.number,\n            exit: prop_types_1.default.number,\n            stagger: prop_types_1.default.number,\n            delay: prop_types_1.default.number,\n            offset: prop_types_1.default.number\n        }),\n        animate: prop_types_1.default.bool,\n        root: prop_types_1.default.bool,\n        merge: prop_types_1.default.bool,\n        combine: prop_types_1.default.bool,\n        manager: prop_types_1.default.oneOfType([\n            prop_types_1.default.oneOf([constants_1.PARALLEL, constants_1.SEQUENCE, constants_1.STAGGER]),\n            prop_types_1.default.func\n        ]),\n        onAnimateMount: prop_types_1.default.func,\n        onAnimateEntering: prop_types_1.default.func,\n        onAnimateEntered: prop_types_1.default.func,\n        onAnimateExiting: prop_types_1.default.func,\n        onAnimateExited: prop_types_1.default.func,\n        onAnimateUnmount: prop_types_1.default.func,\n        activate: prop_types_1.default.bool,\n        onTransition: prop_types_1.default.func\n    }),\n    children: prop_types_1.default.any\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}