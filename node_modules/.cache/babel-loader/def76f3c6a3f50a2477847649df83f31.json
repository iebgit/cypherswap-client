{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexport class Coder {\n  constructor(name, type, localName, dynamic) {\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n  _throwError(message, value) {\n    logger.throwArgumentError(message, this.localName, value);\n  }\n}\nexport class Writer {\n  constructor(wordSize) {\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n  get data() {\n    return hexConcat(this._data);\n  }\n  get length() {\n    return this._dataLength;\n  }\n  _writeData(data) {\n    this._data.push(data);\n    this._dataLength += data.length;\n    return data.length;\n  }\n  appendWriter(writer) {\n    return this._writeData(concat(writer._data));\n  }\n  // Arrayish items; padded on the right to wordSize\n  writeBytes(value) {\n    let bytes = arrayify(value);\n    const paddingOffset = bytes.length % this.wordSize;\n    if (paddingOffset) {\n      bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n    }\n    return this._writeData(bytes);\n  }\n  _getValue(value) {\n    let bytes = arrayify(BigNumber.from(value));\n    if (bytes.length > this.wordSize) {\n      logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n        length: this.wordSize,\n        offset: bytes.length\n      });\n    }\n    if (bytes.length % this.wordSize) {\n      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n    }\n    return bytes;\n  }\n  // BigNumberish items; padded on the left to wordSize\n  writeValue(value) {\n    return this._writeData(this._getValue(value));\n  }\n  writeUpdatableValue() {\n    const offset = this._data.length;\n    this._data.push(this._padding);\n    this._dataLength += this.wordSize;\n    return value => {\n      this._data[offset] = this._getValue(value);\n    };\n  }\n}\nexport class Reader {\n  constructor(data, wordSize, coerceFunc, allowLoose) {\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n  get data() {\n    return hexlify(this._data);\n  }\n  get consumed() {\n    return this._offset;\n  }\n  // The default Coerce function\n  static coerce(name, value) {\n    let match = name.match(\"^u?int([0-9]+)$\");\n    if (match && parseInt(match[1]) <= 48) {\n      value = value.toNumber();\n    }\n    return value;\n  }\n  coerce(name, value) {\n    if (this._coerceFunc) {\n      return this._coerceFunc(name, value);\n    }\n    return Reader.coerce(name, value);\n  }\n  _peekBytes(offset, length, loose) {\n    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n    if (this._offset + alignedLength > this._data.length) {\n      if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n        alignedLength = length;\n      } else {\n        logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this._data.length,\n          offset: this._offset + alignedLength\n        });\n      }\n    }\n    return this._data.slice(this._offset, this._offset + alignedLength);\n  }\n  subReader(offset) {\n    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n  }\n  readBytes(length, loose) {\n    let bytes = this._peekBytes(0, length, !!loose);\n    this._offset += bytes.length;\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  readValue() {\n    return BigNumber.from(this.readBytes(this.wordSize));\n  }\n}","map":{"version":3,"sources":["../../src.ts/coders/abstract-coder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return hexConcat(this._data);\n    }\n    get length() { return this._dataLength; }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            }\n            else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map"]},"metadata":{},"sourceType":"module"}