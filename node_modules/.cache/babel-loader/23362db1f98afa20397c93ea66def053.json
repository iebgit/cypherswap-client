{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startTextAnimation = exports.stopTextAnimation = void 0;\nvar css_1 = require(\"@emotion/css\");\nvar walkTextNodes_1 = require(\"../walkTextNodes\");\nvar setTextNodesEnteringContentLength_1 = require(\"../setTextNodesEnteringContentLength\");\nvar setTextNodesExitingContentLength_1 = require(\"../setTextNodesExitingContentLength\");\n// TODO: Since these styles could be used simultaneously by many components,\n// should these styles be memoized to improve performance?\nvar styles = {\n  cloneNode: {\n    display: 'inline-block',\n    position: 'absolute',\n    zIndex: 0,\n    left: '0',\n    right: '0',\n    top: '0',\n    overflow: 'hidden',\n    userSelect: 'none'\n  }\n};\nvar stopTextAnimation = function (animator, refs) {\n  var _a = refs.current,\n    rootRef = _a.rootRef,\n    actualChildrenRef = _a.actualChildrenRef,\n    cloneNode = _a.cloneNode,\n    animationFrame = _a.animationFrame;\n  // If there is no animation running, nothing needs to be stopped.\n  if (animationFrame.current === null) {\n    return;\n  }\n  window.cancelAnimationFrame(animationFrame.current);\n  if (rootRef.current && cloneNode.current) {\n    rootRef.current.removeChild(cloneNode.current);\n    cloneNode.current = null;\n  }\n  var isEntering = animator.flow.entering || animator.flow.entered;\n  if (isEntering && actualChildrenRef.current) {\n    actualChildrenRef.current.style.opacity = '1';\n  }\n  animationFrame.current = null;\n};\nexports.stopTextAnimation = stopTextAnimation;\nvar startTextAnimation = function (animator, refs, callback) {\n  var _a, _b;\n  var _c = refs.current,\n    rootRef = _c.rootRef,\n    actualChildrenRef = _c.actualChildrenRef,\n    cloneNode = _c.cloneNode,\n    blinkNode = _c.blinkNode,\n    animationFrame = _c.animationFrame;\n  stopTextAnimation(animator, refs);\n  // If the animation is run when the element is already ENTERED, it should\n  // restart the same entering animation.\n  var isEntering = animator.flow.entering || animator.flow.entered;\n  var durationTotal = isEntering ? animator.duration.enter : animator.duration.exit;\n  cloneNode.current = (_a = actualChildrenRef.current) === null || _a === void 0 ? void 0 : _a.cloneNode(true);\n  var textNodes = [];\n  var texts = [];\n  walkTextNodes_1.walkTextNodes(cloneNode.current, function (child) {\n    textNodes.push(child);\n    texts.push(child.textContent || '');\n    if (isEntering) {\n      child.textContent = '';\n    }\n  });\n  var lengthTotal = texts.join('').length;\n  if (!lengthTotal) {\n    cloneNode.current = null;\n    return;\n  }\n  if (actualChildrenRef.current) {\n    actualChildrenRef.current.style.opacity = '0';\n  }\n  cloneNode.current.setAttribute('style', '');\n  cloneNode.current.setAttribute('class', css_1.css(styles.cloneNode));\n  (_b = rootRef.current) === null || _b === void 0 ? void 0 : _b.appendChild(cloneNode.current);\n  if (blinkNode.current) {\n    cloneNode.current.appendChild(blinkNode.current);\n  }\n  var timeStart = 0;\n  var durationProgress = 0;\n  var addNextFrame = function (callback) {\n    animationFrame.current = window.requestAnimationFrame(callback);\n  };\n  var runFrame = function (timestamp) {\n    if (!timeStart) {\n      timeStart = timestamp;\n    }\n    durationProgress = Math.max(timestamp - timeStart, 0);\n    if (!isEntering) {\n      durationProgress = durationTotal - durationProgress;\n    }\n    // partialLength(n) = animationProgressDuration(ms)\n    // textTotalLength(n) = totalDuration(ms)\n    var lengthNew = Math.round(durationProgress * lengthTotal / durationTotal);\n    if (isEntering) {\n      setTextNodesEnteringContentLength_1.setTextNodesEnteringContentLength(textNodes, texts, lengthNew);\n    } else {\n      setTextNodesExitingContentLength_1.setTextNodesExitingContentLength(textNodes, texts, lengthNew, lengthTotal);\n    }\n    var continueAnimation = isEntering ? lengthNew < lengthTotal : lengthNew > 0;\n    if (continueAnimation) {\n      addNextFrame(runFrame);\n    } else {\n      stopTextAnimation(animator, refs);\n      callback === null || callback === void 0 ? void 0 : callback();\n    }\n  };\n  addNextFrame(runFrame);\n};\nexports.startTextAnimation = startTextAnimation;","map":{"version":3,"names":["Object","defineProperty","exports","value","startTextAnimation","stopTextAnimation","css_1","require","walkTextNodes_1","setTextNodesEnteringContentLength_1","setTextNodesExitingContentLength_1","styles","cloneNode","display","position","zIndex","left","right","top","overflow","userSelect","animator","refs","_a","current","rootRef","actualChildrenRef","animationFrame","window","cancelAnimationFrame","removeChild","isEntering","flow","entering","entered","style","opacity","callback","_b","_c","blinkNode","durationTotal","duration","enter","exit","textNodes","texts","walkTextNodes","child","push","textContent","lengthTotal","join","length","setAttribute","css","appendChild","timeStart","durationProgress","addNextFrame","requestAnimationFrame","runFrame","timestamp","Math","max","lengthNew","round","setTextNodesEnteringContentLength","setTextNodesExitingContentLength","continueAnimation"],"sources":["/Users/Ibis/Projects/project_mern_memories/client/node_modules/@arwes/core/lib/utils/textAnimations/textAnimations.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.startTextAnimation = exports.stopTextAnimation = void 0;\nvar css_1 = require(\"@emotion/css\");\nvar walkTextNodes_1 = require(\"../walkTextNodes\");\nvar setTextNodesEnteringContentLength_1 = require(\"../setTextNodesEnteringContentLength\");\nvar setTextNodesExitingContentLength_1 = require(\"../setTextNodesExitingContentLength\");\n// TODO: Since these styles could be used simultaneously by many components,\n// should these styles be memoized to improve performance?\nvar styles = {\n    cloneNode: {\n        display: 'inline-block',\n        position: 'absolute',\n        zIndex: 0,\n        left: '0',\n        right: '0',\n        top: '0',\n        overflow: 'hidden',\n        userSelect: 'none'\n    }\n};\nvar stopTextAnimation = function (animator, refs) {\n    var _a = refs.current, rootRef = _a.rootRef, actualChildrenRef = _a.actualChildrenRef, cloneNode = _a.cloneNode, animationFrame = _a.animationFrame;\n    // If there is no animation running, nothing needs to be stopped.\n    if (animationFrame.current === null) {\n        return;\n    }\n    window.cancelAnimationFrame(animationFrame.current);\n    if (rootRef.current && cloneNode.current) {\n        rootRef.current.removeChild(cloneNode.current);\n        cloneNode.current = null;\n    }\n    var isEntering = animator.flow.entering || animator.flow.entered;\n    if (isEntering && actualChildrenRef.current) {\n        actualChildrenRef.current.style.opacity = '1';\n    }\n    animationFrame.current = null;\n};\nexports.stopTextAnimation = stopTextAnimation;\nvar startTextAnimation = function (animator, refs, callback) {\n    var _a, _b;\n    var _c = refs.current, rootRef = _c.rootRef, actualChildrenRef = _c.actualChildrenRef, cloneNode = _c.cloneNode, blinkNode = _c.blinkNode, animationFrame = _c.animationFrame;\n    stopTextAnimation(animator, refs);\n    // If the animation is run when the element is already ENTERED, it should\n    // restart the same entering animation.\n    var isEntering = animator.flow.entering || animator.flow.entered;\n    var durationTotal = isEntering\n        ? animator.duration.enter\n        : animator.duration.exit;\n    cloneNode.current = (_a = actualChildrenRef.current) === null || _a === void 0 ? void 0 : _a.cloneNode(true);\n    var textNodes = [];\n    var texts = [];\n    walkTextNodes_1.walkTextNodes(cloneNode.current, function (child) {\n        textNodes.push(child);\n        texts.push(child.textContent || '');\n        if (isEntering) {\n            child.textContent = '';\n        }\n    });\n    var lengthTotal = texts.join('').length;\n    if (!lengthTotal) {\n        cloneNode.current = null;\n        return;\n    }\n    if (actualChildrenRef.current) {\n        actualChildrenRef.current.style.opacity = '0';\n    }\n    cloneNode.current.setAttribute('style', '');\n    cloneNode.current.setAttribute('class', css_1.css(styles.cloneNode));\n    (_b = rootRef.current) === null || _b === void 0 ? void 0 : _b.appendChild(cloneNode.current);\n    if (blinkNode.current) {\n        cloneNode.current.appendChild(blinkNode.current);\n    }\n    var timeStart = 0;\n    var durationProgress = 0;\n    var addNextFrame = function (callback) {\n        animationFrame.current = window.requestAnimationFrame(callback);\n    };\n    var runFrame = function (timestamp) {\n        if (!timeStart) {\n            timeStart = timestamp;\n        }\n        durationProgress = Math.max(timestamp - timeStart, 0);\n        if (!isEntering) {\n            durationProgress = durationTotal - durationProgress;\n        }\n        // partialLength(n) = animationProgressDuration(ms)\n        // textTotalLength(n) = totalDuration(ms)\n        var lengthNew = Math.round((durationProgress * lengthTotal) / durationTotal);\n        if (isEntering) {\n            setTextNodesEnteringContentLength_1.setTextNodesEnteringContentLength(textNodes, texts, lengthNew);\n        }\n        else {\n            setTextNodesExitingContentLength_1.setTextNodesExitingContentLength(textNodes, texts, lengthNew, lengthTotal);\n        }\n        var continueAnimation = isEntering\n            ? lengthNew < lengthTotal\n            : lengthNew > 0;\n        if (continueAnimation) {\n            addNextFrame(runFrame);\n        }\n        else {\n            stopTextAnimation(animator, refs);\n            callback === null || callback === void 0 ? void 0 : callback();\n        }\n    };\n    addNextFrame(runFrame);\n};\nexports.startTextAnimation = startTextAnimation;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,kBAAkB,GAAGF,OAAO,CAACG,iBAAiB,GAAG,KAAK,CAAC;AAC/D,IAAIC,KAAK,GAAGC,OAAO,CAAC,cAAc,CAAC;AACnC,IAAIC,eAAe,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AACjD,IAAIE,mCAAmC,GAAGF,OAAO,CAAC,sCAAsC,CAAC;AACzF,IAAIG,kCAAkC,GAAGH,OAAO,CAAC,qCAAqC,CAAC;AACvF;AACA;AACA,IAAII,MAAM,GAAG;EACTC,SAAS,EAAE;IACPC,OAAO,EAAE,cAAc;IACvBC,QAAQ,EAAE,UAAU;IACpBC,MAAM,EAAE,CAAC;IACTC,IAAI,EAAE,GAAG;IACTC,KAAK,EAAE,GAAG;IACVC,GAAG,EAAE,GAAG;IACRC,QAAQ,EAAE,QAAQ;IAClBC,UAAU,EAAE;EAChB;AACJ,CAAC;AACD,IAAIf,iBAAiB,GAAG,UAAUgB,QAAQ,EAAEC,IAAI,EAAE;EAC9C,IAAIC,EAAE,GAAGD,IAAI,CAACE,OAAO;IAAEC,OAAO,GAAGF,EAAE,CAACE,OAAO;IAAEC,iBAAiB,GAAGH,EAAE,CAACG,iBAAiB;IAAEd,SAAS,GAAGW,EAAE,CAACX,SAAS;IAAEe,cAAc,GAAGJ,EAAE,CAACI,cAAc;EACnJ;EACA,IAAIA,cAAc,CAACH,OAAO,KAAK,IAAI,EAAE;IACjC;EACJ;EACAI,MAAM,CAACC,oBAAoB,CAACF,cAAc,CAACH,OAAO,CAAC;EACnD,IAAIC,OAAO,CAACD,OAAO,IAAIZ,SAAS,CAACY,OAAO,EAAE;IACtCC,OAAO,CAACD,OAAO,CAACM,WAAW,CAAClB,SAAS,CAACY,OAAO,CAAC;IAC9CZ,SAAS,CAACY,OAAO,GAAG,IAAI;EAC5B;EACA,IAAIO,UAAU,GAAGV,QAAQ,CAACW,IAAI,CAACC,QAAQ,IAAIZ,QAAQ,CAACW,IAAI,CAACE,OAAO;EAChE,IAAIH,UAAU,IAAIL,iBAAiB,CAACF,OAAO,EAAE;IACzCE,iBAAiB,CAACF,OAAO,CAACW,KAAK,CAACC,OAAO,GAAG,GAAG;EACjD;EACAT,cAAc,CAACH,OAAO,GAAG,IAAI;AACjC,CAAC;AACDtB,OAAO,CAACG,iBAAiB,GAAGA,iBAAiB;AAC7C,IAAID,kBAAkB,GAAG,UAAUiB,QAAQ,EAAEC,IAAI,EAAEe,QAAQ,EAAE;EACzD,IAAId,EAAE,EAAEe,EAAE;EACV,IAAIC,EAAE,GAAGjB,IAAI,CAACE,OAAO;IAAEC,OAAO,GAAGc,EAAE,CAACd,OAAO;IAAEC,iBAAiB,GAAGa,EAAE,CAACb,iBAAiB;IAAEd,SAAS,GAAG2B,EAAE,CAAC3B,SAAS;IAAE4B,SAAS,GAAGD,EAAE,CAACC,SAAS;IAAEb,cAAc,GAAGY,EAAE,CAACZ,cAAc;EAC7KtB,iBAAiB,CAACgB,QAAQ,EAAEC,IAAI,CAAC;EACjC;EACA;EACA,IAAIS,UAAU,GAAGV,QAAQ,CAACW,IAAI,CAACC,QAAQ,IAAIZ,QAAQ,CAACW,IAAI,CAACE,OAAO;EAChE,IAAIO,aAAa,GAAGV,UAAU,GACxBV,QAAQ,CAACqB,QAAQ,CAACC,KAAK,GACvBtB,QAAQ,CAACqB,QAAQ,CAACE,IAAI;EAC5BhC,SAAS,CAACY,OAAO,GAAG,CAACD,EAAE,GAAGG,iBAAiB,CAACF,OAAO,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACX,SAAS,CAAC,IAAI,CAAC;EAC5G,IAAIiC,SAAS,GAAG,EAAE;EAClB,IAAIC,KAAK,GAAG,EAAE;EACdtC,eAAe,CAACuC,aAAa,CAACnC,SAAS,CAACY,OAAO,EAAE,UAAUwB,KAAK,EAAE;IAC9DH,SAAS,CAACI,IAAI,CAACD,KAAK,CAAC;IACrBF,KAAK,CAACG,IAAI,CAACD,KAAK,CAACE,WAAW,IAAI,EAAE,CAAC;IACnC,IAAInB,UAAU,EAAE;MACZiB,KAAK,CAACE,WAAW,GAAG,EAAE;IAC1B;EACJ,CAAC,CAAC;EACF,IAAIC,WAAW,GAAGL,KAAK,CAACM,IAAI,CAAC,EAAE,CAAC,CAACC,MAAM;EACvC,IAAI,CAACF,WAAW,EAAE;IACdvC,SAAS,CAACY,OAAO,GAAG,IAAI;IACxB;EACJ;EACA,IAAIE,iBAAiB,CAACF,OAAO,EAAE;IAC3BE,iBAAiB,CAACF,OAAO,CAACW,KAAK,CAACC,OAAO,GAAG,GAAG;EACjD;EACAxB,SAAS,CAACY,OAAO,CAAC8B,YAAY,CAAC,OAAO,EAAE,EAAE,CAAC;EAC3C1C,SAAS,CAACY,OAAO,CAAC8B,YAAY,CAAC,OAAO,EAAEhD,KAAK,CAACiD,GAAG,CAAC5C,MAAM,CAACC,SAAS,CAAC,CAAC;EACpE,CAAC0B,EAAE,GAAGb,OAAO,CAACD,OAAO,MAAM,IAAI,IAAIc,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACkB,WAAW,CAAC5C,SAAS,CAACY,OAAO,CAAC;EAC7F,IAAIgB,SAAS,CAAChB,OAAO,EAAE;IACnBZ,SAAS,CAACY,OAAO,CAACgC,WAAW,CAAChB,SAAS,CAAChB,OAAO,CAAC;EACpD;EACA,IAAIiC,SAAS,GAAG,CAAC;EACjB,IAAIC,gBAAgB,GAAG,CAAC;EACxB,IAAIC,YAAY,GAAG,UAAUtB,QAAQ,EAAE;IACnCV,cAAc,CAACH,OAAO,GAAGI,MAAM,CAACgC,qBAAqB,CAACvB,QAAQ,CAAC;EACnE,CAAC;EACD,IAAIwB,QAAQ,GAAG,UAAUC,SAAS,EAAE;IAChC,IAAI,CAACL,SAAS,EAAE;MACZA,SAAS,GAAGK,SAAS;IACzB;IACAJ,gBAAgB,GAAGK,IAAI,CAACC,GAAG,CAACF,SAAS,GAAGL,SAAS,EAAE,CAAC,CAAC;IACrD,IAAI,CAAC1B,UAAU,EAAE;MACb2B,gBAAgB,GAAGjB,aAAa,GAAGiB,gBAAgB;IACvD;IACA;IACA;IACA,IAAIO,SAAS,GAAGF,IAAI,CAACG,KAAK,CAAER,gBAAgB,GAAGP,WAAW,GAAIV,aAAa,CAAC;IAC5E,IAAIV,UAAU,EAAE;MACZtB,mCAAmC,CAAC0D,iCAAiC,CAACtB,SAAS,EAAEC,KAAK,EAAEmB,SAAS,CAAC;IACtG,CAAC,MACI;MACDvD,kCAAkC,CAAC0D,gCAAgC,CAACvB,SAAS,EAAEC,KAAK,EAAEmB,SAAS,EAAEd,WAAW,CAAC;IACjH;IACA,IAAIkB,iBAAiB,GAAGtC,UAAU,GAC5BkC,SAAS,GAAGd,WAAW,GACvBc,SAAS,GAAG,CAAC;IACnB,IAAII,iBAAiB,EAAE;MACnBV,YAAY,CAACE,QAAQ,CAAC;IAC1B,CAAC,MACI;MACDxD,iBAAiB,CAACgB,QAAQ,EAAEC,IAAI,CAAC;MACjCe,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,EAAE;IAClE;EACJ,CAAC;EACDsB,YAAY,CAACE,QAAQ,CAAC;AAC1B,CAAC;AACD3D,OAAO,CAACE,kBAAkB,GAAGA,kBAAkB"},"metadata":{},"sourceType":"script"}