{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _isNaN from \"lodash/isNaN\";\nimport _upperFirst from \"lodash/upperFirst\";\nimport _isString from \"lodash/isString\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport * as d3Scales from 'd3-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { isNumOrStr, uniqueId, isNumber, getPercentValue, mathSign, findEntryInArray } from './DataUtils';\nimport { Legend } from '../component/Legend';\nimport { findAllByType, findChildByType, getDisplayName } from './ReactUtils'; // TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n\nimport { filterProps } from './types';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData; // 支持Date类型的x轴\n\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) || entry instanceof Date ? entry : '';\n  });\n}\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n  var _ticks$length;\n  var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n  var axis = arguments.length > 3 ? arguments[3] : undefined;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n  if (len > 1) {\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n      var range = axis.range; // ticks are distributed in a circle\n\n      for (var i = 0; i < len; i++) {\n        var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n        var cur = unsortedTicks[i].coordinate;\n        var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n        var sameDirectionCoord = void 0;\n        if (mathSign(cur - before) !== mathSign(after - cur)) {\n          var diffInterval = [];\n          if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n            sameDirectionCoord = after;\n            var curInRange = cur + range[1] - range[0];\n            diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n            diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n          } else {\n            sameDirectionCoord = before;\n            var afterInRange = after + range[1] - range[0];\n            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n          }\n          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        } else {\n          var min = Math.min(before, after);\n          var max = Math.max(before, after);\n          if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        }\n      }\n    } else {\n      // ticks are distributed in a single direction\n      for (var _i = 0; _i < len; _i++) {\n        if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n          index = ticks[_i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    index = 0;\n  }\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var _ref = item,\n    displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n\n  var _item$props = item.props,\n    stroke = _item$props.stroke,\n    fill = _item$props.fill;\n  var result;\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n    default:\n      result = fill;\n      break;\n  }\n  return result;\n};\nexport var getLegendProps = function getLegendProps(_ref2) {\n  var children = _ref2.children,\n    formattedGraphicalItems = _ref2.formattedGraphicalItems,\n    legendWidth = _ref2.legendWidth,\n    legendContent = _ref2.legendContent;\n  var legendItem = findChildByType(children, Legend.displayName);\n  if (!legendItem) {\n    return null;\n  }\n  var legendData;\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formattedGraphicalItems || []).reduce(function (result, _ref3) {\n      var item = _ref3.item,\n        props = _ref3.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formattedGraphicalItems || []).map(function (_ref4) {\n      var item = _ref4.item;\n      var _item$props2 = item.props,\n        dataKey = _item$props2.dataKey,\n        name = _item$props2.name,\n        legendType = _item$props2.legendType,\n        hide = _item$props2.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n  return _objectSpread(_objectSpread(_objectSpread({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref5) {\n  var globalSize = _ref5.barSize,\n    _ref5$stackGroups = _ref5.stackGroups,\n    stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;\n  if (!stackGroups) {\n    return {};\n  }\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n        items = _sgs$stackIds$j.items,\n        cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n  return result;\n};\n/**\n * Calculate the size of each bar and the gap between two bars\n * @param  {Number} bandSize  The size of each category\n * @param  {sizeList} sizeList  The size of all groups\n * @param  {maxBarSize} maxBarSize The maximum size of bar\n * @return {Number} The size of each bar and the gap between two bars\n */\n\nexport var getBarPosition = function getBarPosition(_ref6) {\n  var barGap = _ref6.barGap,\n    barCategoryGap = _ref6.barCategoryGap,\n    bandSize = _ref6.bandSize,\n    _ref6$sizeList = _ref6.sizeList,\n    sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList,\n    maxBarSize = _ref6.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n      prev = newRes[newRes.length - 1].position;\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n      return newRes;\n    }, []);\n  }\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n    width = props.width,\n    margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0); // const legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n\n  var legendProps = getLegendProps({\n    children: children,\n    legendWidth: legendWidth\n  });\n  var newOffset = offset;\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n      verticalAlign = legendProps.verticalAlign,\n      layout = legendProps.layout;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n  return newOffset;\n};\nvar isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {\n  if (_isNil(axisType)) {\n    return true;\n  }\n  if (layout === 'horizontal') {\n    return axisType === 'yAxis';\n  }\n  if (layout === 'vertical') {\n    return axisType === 'xAxis';\n  }\n  if (direction === 'x') {\n    return axisType === 'xAxis';\n  }\n  if (direction === 'y') {\n    return axisType === 'yAxis';\n  }\n  return true;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, 'ErrorBar').filter(function (errorBarChild) {\n    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);\n  });\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, layout, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {LayoutType} layout The type of layout\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n    return result;\n  }, []);\n};\nexport var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(min);\n  }\n  if (!hasMax) {\n    values.push(max);\n  }\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n    type = axis.type,\n    range = axis.range;\n  var offsetForBand = axis.realScaleType === 'scaleBand' ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n  if (axis.isCategorical && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @param  {Boolean}  hasBar        if it has a bar\n * @return {Function}               The scale function\n */\n\nexport var parseScale = function parseScale(axis, chartType, hasBar) {\n  var scale = axis.scale,\n    type = axis.type,\n    layout = axis.layout,\n    axisType = axis.axisType;\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n  if (_isString(scale)) {\n    var name = \"scale\".concat(_upperFirst(scale));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n  if (result[0] > max) {\n    result[0] = max;\n  }\n  if (result[1] < min) {\n    result[1] = min;\n  }\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n    }\n  }\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetPositive = function offsetPositive(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring */\n    }\n  }\n};\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props3 = item.props,\n      stackId = _item$props3.stackId,\n      hide = _item$props3.hide;\n    if (hide) {\n      return result;\n    }\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\n\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [_min(ticks), _max(ticks)];\n  }\n  return ticks;\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n    type = opts.type,\n    tickCount = opts.tickCount,\n    originalDomain = opts.originalDomain,\n    allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    if (!domain.length) {\n      return null;\n    }\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  }\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n    return {\n      niceTicks: _tickValues\n    };\n  }\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref7) {\n  var axis = _ref7.axis,\n    ticks = _ref7.ticks,\n    bandSize = _ref7.bandSize,\n    entry = _ref7.entry,\n    index = _ref7.index,\n    dataKey = _ref7.dataKey;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref8) {\n  var axis = _ref8.axis,\n    ticks = _ref8.ticks,\n    offset = _ref8.offset,\n    bandSize = _ref8.bandSize,\n    entry = _ref8.entry,\n    index = _ref8.index;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref9) {\n  var numericAxis = _ref9.numericAxis;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n    if (max < 0) {\n      return max;\n    }\n    return min;\n  }\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n    if (group && group.items.length) {\n      var itemIndex = -1;\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n  return null;\n};\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (_isFunction(specifiedDomain)) {\n    return specifiedDomain(dataDomain, allowDataOverflow);\n  }\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n  return specifiedDomain;\n};\nexport var getTooltipItem = function getTooltipItem(graphicalItem, payload) {\n  var _graphicalItem$props = graphicalItem.props,\n    dataKey = _graphicalItem$props.dataKey,\n    name = _graphicalItem$props.name,\n    unit = _graphicalItem$props.unit,\n    formatter = _graphicalItem$props.formatter,\n    tooltipType = _graphicalItem$props.tooltipType,\n    chartType = _graphicalItem$props.chartType;\n  return _objectSpread(_objectSpread({}, filterProps(graphicalItem)), {}, {\n    dataKey: dataKey,\n    unit: unit,\n    formatter: formatter,\n    name: name || dataKey,\n    color: getMainColorOfGraphicItem(graphicalItem),\n    value: getValueByDataKey(payload, dataKey),\n    type: tooltipType,\n    payload: payload,\n    chartType: chartType\n  });\n};","map":{"version":3,"names":["_isEqual","_sortBy","_isNaN","_upperFirst","_isString","_isArray","_max","_min","_flatMap","_isFunction","_get","_isNil","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","getNiceTickValues","getTickValuesFixedDomain","d3Scales","stack","shapeStack","stackOrderNone","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","isNumOrStr","uniqueId","isNumber","getPercentValue","mathSign","findEntryInArray","Legend","findAllByType","findChildByType","getDisplayName","filterProps","getValueByDataKey","dataKey","defaultValue","getDomainOfDataByKey","data","type","filterNil","flattenData","entry","domain","parseFloat","Infinity","validateData","map","Date","calculateActiveTickIndex","coordinate","_ticks$length","ticks","undefined","unsortedTicks","axis","index","axisType","Math","abs","range","before","cur","after","sameDirectionCoord","diffInterval","curInRange","min","max","afterInRange","sameInterval","_i","getMainColorOfGraphicItem","item","_ref","displayName","_item$props","props","stroke","fill","result","getLegendProps","_ref2","children","formattedGraphicalItems","legendWidth","legendContent","legendItem","legendData","payload","reduce","_ref3","sectors","concat","iconType","legendType","color","_ref4","_item$props2","hide","inactive","getWithHeight","getBarSizeList","_ref5","globalSize","barSize","_ref5$stackGroups","stackGroups","numericAxisIds","sgs","stackIds","j","sLen","_sgs$stackIds$j","items","cateAxisId","barItems","indexOf","selfSize","cateId","stackList","getBarPosition","_ref6","barGap","barCategoryGap","bandSize","_ref6$sizeList","sizeList","maxBarSize","realBarGap","useFull","fullBarSize","sum","res","offset","prev","size","newRes","position","_offset","originalSize","appendOffsetOfLegend","legendBox","width","margin","left","right","legendProps","newOffset","box","align","verticalAlign","layout","height","isErrorBarRelevantForAxis","direction","getDomainOfErrorBars","errorBars","errorBarChild","entryValue","mainValue","errorDomain","prevErrorArr","k","errorValue","lowerValue","upperValue","parseErrorBarsOfAxis","domains","getDomainOfItemsWithSameAxis","tag","isCategoricalAxis","getCoordinatesOfGrid","hasMin","hasMax","values","getTicksOfAxis","isGrid","isAll","scale","duplicateDomain","offsetForBand","realScaleType","bandwidth","niceTicks","scaleContent","isCategorical","categoricalDomain","tickCount","combineEventHandlers","defaultHandler","parentHandler","childHandler","customizedHandler","arg1","arg2","arg3","arg4","parseScale","chartType","hasBar","scaleBand","scaleLinear","scalePoint","EPS","checkDomainOfScale","first","last","findPositionOfBar","barPosition","child","truncateByDomain","offsetSign","series","m","positive","negative","offsetPositive","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","stackItems","offsetType","dataKeys","d","order","getStackGroupsByAxisId","_items","numericAxisId","reverseStackOrder","reverse","_item$props3","stackId","axisId","parentGroup","hasStack","childGroup","group","g","stackedData","calculateDomainOfTicks","getTicksOfScale","opts","originalDomain","allowDecimals","scaleType","tickValues","_domain","_tickValues","getCateCoordinateOfLine","_ref7","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref8","getBaseValueOfBar","_ref9","numericAxis","getStackedDataOfItem","itemIndex","getDomainOfSingle","getDomainOfStackGroups","startIndex","endIndex","s","MIN_VALUE_REG","MAX_VALUE_REG","parseSpecifiedDomain","specifiedDomain","dataDomain","allowDataOverflow","exec","_value","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","parseDomainOfCategoryAxis","calculatedDomain","axisChild","getTooltipItem","graphicalItem","_graphicalItem$props","unit","formatter","tooltipType"],"sources":["/Users/Ibis/Projects/project_mern_memories/client/node_modules/recharts/es6/util/ChartUtils.js"],"sourcesContent":["import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _isNaN from \"lodash/isNaN\";\nimport _upperFirst from \"lodash/upperFirst\";\nimport _isString from \"lodash/isString\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport * as d3Scales from 'd3-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { isNumOrStr, uniqueId, isNumber, getPercentValue, mathSign, findEntryInArray } from './DataUtils';\nimport { Legend } from '../component/Legend';\nimport { findAllByType, findChildByType, getDisplayName } from './ReactUtils'; // TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n\nimport { filterProps } from './types';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n}\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData; // 支持Date类型的x轴\n\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) || entry instanceof Date ? entry : '';\n  });\n}\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n  var _ticks$length;\n\n  var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n  var axis = arguments.length > 3 ? arguments[3] : undefined;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n\n  if (len > 1) {\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n      var range = axis.range; // ticks are distributed in a circle\n\n      for (var i = 0; i < len; i++) {\n        var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n        var cur = unsortedTicks[i].coordinate;\n        var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n        var sameDirectionCoord = void 0;\n\n        if (mathSign(cur - before) !== mathSign(after - cur)) {\n          var diffInterval = [];\n\n          if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n            sameDirectionCoord = after;\n            var curInRange = cur + range[1] - range[0];\n            diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n            diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n          } else {\n            sameDirectionCoord = before;\n            var afterInRange = after + range[1] - range[0];\n            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n          }\n\n          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n\n          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        } else {\n          var min = Math.min(before, after);\n          var max = Math.max(before, after);\n\n          if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        }\n      }\n    } else {\n      // ticks are distributed in a single direction\n      for (var _i = 0; _i < len; _i++) {\n        if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n          index = ticks[_i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    index = 0;\n  }\n\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var _ref = item,\n      displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n\n  var _item$props = item.props,\n      stroke = _item$props.stroke,\n      fill = _item$props.fill;\n  var result;\n\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n\n    default:\n      result = fill;\n      break;\n  }\n\n  return result;\n};\nexport var getLegendProps = function getLegendProps(_ref2) {\n  var children = _ref2.children,\n      formattedGraphicalItems = _ref2.formattedGraphicalItems,\n      legendWidth = _ref2.legendWidth,\n      legendContent = _ref2.legendContent;\n  var legendItem = findChildByType(children, Legend.displayName);\n\n  if (!legendItem) {\n    return null;\n  }\n\n  var legendData;\n\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formattedGraphicalItems || []).reduce(function (result, _ref3) {\n      var item = _ref3.item,\n          props = _ref3.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formattedGraphicalItems || []).map(function (_ref4) {\n      var item = _ref4.item;\n      var _item$props2 = item.props,\n          dataKey = _item$props2.dataKey,\n          name = _item$props2.name,\n          legendType = _item$props2.legendType,\n          hide = _item$props2.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n\n  return _objectSpread(_objectSpread(_objectSpread({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref5) {\n  var globalSize = _ref5.barSize,\n      _ref5$stackGroups = _ref5.stackGroups,\n      stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;\n\n  if (!stackGroups) {\n    return {};\n  }\n\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n          items = _sgs$stackIds$j.items,\n          cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Calculate the size of each bar and the gap between two bars\n * @param  {Number} bandSize  The size of each category\n * @param  {sizeList} sizeList  The size of all groups\n * @param  {maxBarSize} maxBarSize The maximum size of bar\n * @return {Number} The size of each bar and the gap between two bars\n */\n\nexport var getBarPosition = function getBarPosition(_ref6) {\n  var barGap = _ref6.barGap,\n      barCategoryGap = _ref6.barCategoryGap,\n      bandSize = _ref6.bandSize,\n      _ref6$sizeList = _ref6.sizeList,\n      sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList,\n      maxBarSize = _ref6.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n      prev = newRes[newRes.length - 1].position;\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  }\n\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n      width = props.width,\n      margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0); // const legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n\n  var legendProps = getLegendProps({\n    children: children,\n    legendWidth: legendWidth\n  });\n  var newOffset = offset;\n\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n        verticalAlign = legendProps.verticalAlign,\n        layout = legendProps.layout;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n\n  return newOffset;\n};\n\nvar isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis(layout, axisType, direction) {\n  if (_isNil(axisType)) {\n    return true;\n  }\n\n  if (layout === 'horizontal') {\n    return axisType === 'yAxis';\n  }\n\n  if (layout === 'vertical') {\n    return axisType === 'xAxis';\n  }\n\n  if (direction === 'x') {\n    return axisType === 'xAxis';\n  }\n\n  if (direction === 'y') {\n    return axisType === 'yAxis';\n  }\n\n  return true;\n};\n\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, layout, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, 'ErrorBar').filter(function (errorBarChild) {\n    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);\n  });\n\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType, layout) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, layout, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {LayoutType} layout The type of layout\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, layout, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n\n    return result;\n  }, []);\n};\nexport var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(min);\n  }\n\n  if (!hasMax) {\n    values.push(max);\n  }\n\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n      type = axis.type,\n      range = axis.range;\n  var offsetForBand = axis.realScaleType === 'scaleBand' ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n\n  if (axis.isCategorical && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @param  {Boolean}  hasBar        if it has a bar\n * @return {Function}               The scale function\n */\n\nexport var parseScale = function parseScale(axis, chartType, hasBar) {\n  var scale = axis.scale,\n      type = axis.type,\n      layout = axis.layout,\n      axisType = axis.axisType;\n\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n\n  if (_isString(scale)) {\n    var name = \"scale\".concat(_upperFirst(scale));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n\n  if (result[0] > max) {\n    result[0] = max;\n  }\n\n  if (result[1] < min) {\n    result[1] = min;\n  }\n\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetPositive = function offsetPositive(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props3 = item.props,\n        stackId = _item$props3.stackId,\n        hide = _item$props3.hide;\n\n    if (hide) {\n      return result;\n    }\n\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\n\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [_min(ticks), _max(ticks)];\n  }\n\n  return ticks;\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n      type = opts.type,\n      tickCount = opts.tickCount,\n      originalDomain = opts.originalDomain,\n      allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n\n    if (!domain.length) {\n      return null;\n    }\n\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  }\n\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n\n    return {\n      niceTicks: _tickValues\n    };\n  }\n\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref7) {\n  var axis = _ref7.axis,\n      ticks = _ref7.ticks,\n      bandSize = _ref7.bandSize,\n      entry = _ref7.entry,\n      index = _ref7.index,\n      dataKey = _ref7.dataKey;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref8) {\n  var axis = _ref8.axis,\n      ticks = _ref8.ticks,\n      offset = _ref8.offset,\n      bandSize = _ref8.bandSize,\n      entry = _ref8.entry,\n      index = _ref8.index;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref9) {\n  var numericAxis = _ref9.numericAxis;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n\n    if (max < 0) {\n      return max;\n    }\n\n    return min;\n  }\n\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n\n    if (group && group.items.length) {\n      var itemIndex = -1;\n\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n\n  return null;\n};\n\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\n\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (_isFunction(specifiedDomain)) {\n    return specifiedDomain(dataDomain, allowDataOverflow);\n  }\n\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return isBar ? undefined : 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n\n  return specifiedDomain;\n};\nexport var getTooltipItem = function getTooltipItem(graphicalItem, payload) {\n  var _graphicalItem$props = graphicalItem.props,\n      dataKey = _graphicalItem$props.dataKey,\n      name = _graphicalItem$props.name,\n      unit = _graphicalItem$props.unit,\n      formatter = _graphicalItem$props.formatter,\n      tooltipType = _graphicalItem$props.tooltipType,\n      chartType = _graphicalItem$props.chartType;\n  return _objectSpread(_objectSpread({}, filterProps(graphicalItem)), {}, {\n    dataKey: dataKey,\n    unit: unit,\n    formatter: formatter,\n    name: name || dataKey,\n    color: getMainColorOfGraphicItem(graphicalItem),\n    value: getValueByDataKey(payload, dataKey),\n    type: tooltipType,\n    payload: payload,\n    chartType: chartType\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}