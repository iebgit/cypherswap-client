{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { addReactionToTrack, recordReactionAsCommitted } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\".concat(baseComponentName);\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */function () {\n  function ObjectToBeRetainedByReact() {}\n  return ObjectToBeRetainedByReact;\n}();\nfunction objectToBeRetainedByReactFactory() {\n  return new ObjectToBeRetainedByReact();\n}\nexport function useObserver(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n  var _a = __read(React.useState(objectToBeRetainedByReactFactory), 1),\n    objectRetainedByReact = _a[0];\n  // Force update, see #2982\n  var _b = __read(React.useState(), 2),\n    setState = _b[1];\n  var forceUpdate = function () {\n    return setState([]);\n  };\n  // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n  var reactionTrackingRef = React.useRef(null);\n  if (!reactionTrackingRef.current) {\n    // First render for this component (or first time since a previous\n    // reaction from an abandoned render was disposed).\n    var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (trackingData_1.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        forceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.\n        trackingData_1.changedBeforeMount = true;\n      }\n    });\n    var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);\n  }\n  var reaction = reactionTrackingRef.current.reaction;\n  React.useDebugValue(reaction, printDebugValue);\n  React.useEffect(function () {\n    // Called on first mount only\n    recordReactionAsCommitted(reactionTrackingRef);\n    if (reactionTrackingRef.current) {\n      // Great. We've already got our reaction from our render;\n      // all we need to do is to record that it's now mounted,\n      // to allow future observable changes to trigger re-renders\n      reactionTrackingRef.current.mounted = true;\n      // Got a change before first mount, force an update\n      if (reactionTrackingRef.current.changedBeforeMount) {\n        reactionTrackingRef.current.changedBeforeMount = false;\n        forceUpdate();\n      }\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This can be due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up\n      // Re-create the reaction\n      reactionTrackingRef.current = {\n        reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n          // We've definitely already been mounted at this point\n          forceUpdate();\n        }),\n        mounted: true,\n        changedBeforeMount: false,\n        cleanAt: Infinity\n      };\n      forceUpdate();\n    }\n    return function () {\n      reactionTrackingRef.current.reaction.dispose();\n      reactionTrackingRef.current = null;\n    };\n  }, []);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var rendering;\n  var exception;\n  reaction.track(function () {\n    try {\n      rendering = fn();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return rendering;\n}","map":{"version":3,"sources":["../src/useObserver.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { addReactionToTrack, recordReactionAsCommitted } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\".concat(baseComponentName);\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */ (function () {\n    function ObjectToBeRetainedByReact() {\n    }\n    return ObjectToBeRetainedByReact;\n}());\nfunction objectToBeRetainedByReactFactory() {\n    return new ObjectToBeRetainedByReact();\n}\nexport function useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var _a = __read(React.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a[0];\n    // Force update, see #2982\n    var _b = __read(React.useState(), 2), setState = _b[1];\n    var forceUpdate = function () { return setState([]); };\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                trackingData_1.changedBeforeMount = true;\n            }\n        });\n        var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n            // Got a change before first mount, force an update\n            if (reactionTrackingRef.current.changedBeforeMount) {\n                reactionTrackingRef.current.changedBeforeMount = false;\n                forceUpdate();\n            }\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    forceUpdate();\n                }),\n                mounted: true,\n                changedBeforeMount: false,\n                cleanAt: Infinity\n            };\n            forceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    reaction.track(function () {\n        try {\n            rendering = fn();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return rendering;\n}\n//# sourceMappingURL=useObserver.js.map"]},"metadata":{},"sourceType":"module"}