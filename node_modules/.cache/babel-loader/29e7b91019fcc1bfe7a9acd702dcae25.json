{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nexport class ForkEvent extends Description {\n  static isForkEvent(value) {\n    return !!(value && value._isForkEvent);\n  }\n}\nexport class BlockForkEvent extends ForkEvent {\n  constructor(blockHash, expiry) {\n    if (!isHexString(blockHash, 32)) {\n      logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n    }\n    super({\n      _isForkEvent: true,\n      _isBlockForkEvent: true,\n      expiry: expiry || 0,\n      blockHash: blockHash\n    });\n  }\n}\nexport class TransactionForkEvent extends ForkEvent {\n  constructor(hash, expiry) {\n    if (!isHexString(hash, 32)) {\n      logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n    }\n    super({\n      _isForkEvent: true,\n      _isTransactionForkEvent: true,\n      expiry: expiry || 0,\n      hash: hash\n    });\n  }\n}\nexport class TransactionOrderForkEvent extends ForkEvent {\n  constructor(beforeHash, afterHash, expiry) {\n    if (!isHexString(beforeHash, 32)) {\n      logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n    }\n    if (!isHexString(afterHash, 32)) {\n      logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n    }\n    super({\n      _isForkEvent: true,\n      _isTransactionOrderForkEvent: true,\n      expiry: expiry || 0,\n      beforeHash: beforeHash,\n      afterHash: afterHash\n    });\n  }\n}\n///////////////////////////////\n// Exported Abstracts\nexport class Provider {\n  constructor() {\n    logger.checkAbstract(new.target, Provider);\n    defineReadOnly(this, \"_isProvider\", true);\n  }\n  getFeeData() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        block,\n        gasPrice\n      } = yield resolveProperties({\n        block: this.getBlock(\"latest\"),\n        gasPrice: this.getGasPrice().catch(error => {\n          // @TODO: Why is this now failing on Calaveras?\n          //console.log(error);\n          return null;\n        })\n      });\n      let lastBaseFeePerGas = null,\n        maxFeePerGas = null,\n        maxPriorityFeePerGas = null;\n      if (block && block.baseFeePerGas) {\n        // We may want to compute this more accurately in the future,\n        // using the formula \"check if the base fee is correct\".\n        // See: https://eips.ethereum.org/EIPS/eip-1559\n        lastBaseFeePerGas = block.baseFeePerGas;\n        maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n      }\n      return {\n        lastBaseFeePerGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        gasPrice\n      };\n    });\n  }\n  // Alias for \"on\"\n  addListener(eventName, listener) {\n    return this.on(eventName, listener);\n  }\n  // Alias for \"off\"\n  removeListener(eventName, listener) {\n    return this.off(eventName, listener);\n  }\n  static isProvider(value) {\n    return !!(value && value._isProvider);\n  }\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"AAAA,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEZ,SAAS,SAAS,QAAsB,0BAA0B;AAClE,SAAoB,WAAW,QAAQ,sBAAsB;AAE7D,SAAqB,WAAW,EAAE,cAAc,EAAE,iBAAiB,QAAQ,2BAA2B;AAItG,SAAS,MAAM,QAAQ,uBAAuB;AAC9C,SAAS,OAAO,QAAQ,YAAY;AACpC,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC;AA8CjC;AAkEA;AAuBD;AACA;AACA;AAEA,OAAM,MAAgB,SAAU,SAAQ,WAAW,CAAA;EAK/C,OAAO,WAAW,CAAC,KAAU,EAAA;IACzB,OAAO,CAAC,EAAE,KAAK,IAAI,KAAK,CAAC,YAAY,CAAC;EAC1C;AACH;AAED,OAAM,MAAO,cAAe,SAAQ,SAAS,CAAA;EAKzC,WAAA,CAAY,SAAiB,EAAE,MAAe,EAAA;IAC1C,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,EAAE,CAAC,EAAE;MAC7B,MAAM,CAAC,kBAAkB,CAAC,mBAAmB,EAAE,WAAW,EAAE,SAAS,CAAC;IACzE;IAED,KAAK,CAAC;MACF,YAAY,EAAE,IAAI;MAClB,iBAAiB,EAAE,IAAI;MACvB,MAAM,EAAG,MAAM,IAAI,CAAE;MACrB,SAAS,EAAE;KACd,CAAC;EACN;AACH;AAED,OAAM,MAAO,oBAAqB,SAAQ,SAAS,CAAA;EAK/C,WAAA,CAAY,IAAY,EAAE,MAAe,EAAA;IACrC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,EAAE,CAAC,EAAE;MACxB,MAAM,CAAC,kBAAkB,CAAC,0BAA0B,EAAE,MAAM,EAAE,IAAI,CAAC;IACtE;IAED,KAAK,CAAC;MACF,YAAY,EAAE,IAAI;MAClB,uBAAuB,EAAE,IAAI;MAC7B,MAAM,EAAG,MAAM,IAAI,CAAE;MACrB,IAAI,EAAE;KACT,CAAC;EACN;AACH;AAED,OAAM,MAAO,yBAA0B,SAAQ,SAAS,CAAA;EAIpD,WAAA,CAAY,UAAkB,EAAE,SAAiB,EAAE,MAAe,EAAA;IAC9D,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,EAAE,CAAC,EAAE;MAC9B,MAAM,CAAC,kBAAkB,CAAC,0BAA0B,EAAE,YAAY,EAAE,UAAU,CAAC;IAClF;IACD,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,EAAE,CAAC,EAAE;MAC7B,MAAM,CAAC,kBAAkB,CAAC,0BAA0B,EAAE,WAAW,EAAE,SAAS,CAAC;IAChF;IAED,KAAK,CAAC;MACF,YAAY,EAAE,IAAI;MAClB,4BAA4B,EAAE,IAAI;MAClC,MAAM,EAAG,MAAM,IAAI,CAAE;MACrB,UAAU,EAAE,UAAU;MACtB,SAAS,EAAE;KACd,CAAC;EACN;AACH;AAMD;AACA;AACA,OAAM,MAAgB,QAAQ,CAAA;EAgF1B,WAAA,GAAA;IACI,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC;IAC1C,cAAc,CAAC,IAAI,EAAE,aAAa,EAAE,IAAI,CAAC;EAC7C;EA3EM,UAAU,GAAA;;MACZ,MAAM;QAAE,KAAK;QAAE;MAAQ,CAAE,GAAG,MAAM,iBAAiB,CAAC;QAChD,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC9B,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,CAAC,KAAK,CAAE,KAAK,IAAI;UACzC;UACA;UACA,OAAO,IAAI;QACf,CAAC;OACJ,CAAC;MAEF,IAAI,iBAAiB,GAAG,IAAI;QAAE,YAAY,GAAG,IAAI;QAAE,oBAAoB,GAAG,IAAI;MAE9E,IAAI,KAAK,IAAI,KAAK,CAAC,aAAa,EAAE;QAC9B;QACA;QACA;QACA,iBAAiB,GAAG,KAAK,CAAC,aAAa;QACvC,oBAAoB,GAAG,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC;QACnD,YAAY,GAAG,KAAK,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,oBAAoB,CAAC;MACtE;MAED,OAAO;QAAE,iBAAiB;QAAE,YAAY;QAAE,oBAAoB;QAAE;MAAQ,CAAE;IAC9E,CAAC,CAAA;EAAA;EAmCD;EACA,WAAW,CAAC,SAAoB,EAAE,QAAkB,EAAA;IAChD,OAAO,IAAI,CAAC,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC;EACvC;EAEA;EACA,cAAc,CAAC,SAAoB,EAAE,QAAkB,EAAA;IACnD,OAAO,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAC;EACxC;EAYA,OAAO,UAAU,CAAC,KAAU,EAAA;IACxB,OAAO,CAAC,EAAE,KAAK,IAAI,KAAK,CAAC,WAAW,CAAC;EACzC;AAyCH","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nexport class ForkEvent extends Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nexport class BlockForkEvent extends ForkEvent {\n    constructor(blockHash, expiry) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\nexport class TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\nexport class TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nexport class Provider {\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { block, gasPrice } = yield resolveProperties({\n                block: this.getBlock(\"latest\"),\n                gasPrice: this.getGasPrice().catch((error) => {\n                    // @TODO: Why is this now failing on Calaveras?\n                    //console.log(error);\n                    return null;\n                })\n            });\n            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n            if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                lastBaseFeePerGas = block.baseFeePerGas;\n                maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n            }\n            return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n        });\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}